{"ast":null,"code":"// import { useState } from \"react\";\n// function App() {\n//   const initialState = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n//   const [array, setArray] = useState(initialState);\n//   const [result, setResult] = useState(\"\");\n//   const [query, setQuery] = useState(\"\");\n//   const a = [1, 2, 3, 4]\n//   delete a[1]\n//   console.log(a)\n\n//   const handleForEach = function () {\n//     let temp = \"\";\n//     array.forEach(function (item, index) {\n//       temp += `${index}: ${item}`;\n//     });\n//     setResult(temp);\n//   };\n\n//   const handleFilter = function () {\n//     const filtered = array.filter((item, index) => item.includes(query));\n//     setResult(filtered.join(\", \"));\n//   };\n\n//   const handleMap = function () {\n//     const mapped = array.map(function (item, index) {\n//       return item.toUpperCase();\n//     });\n//     setResult(mapped);\n//   };\n\n//   // reduce 배열 api 콜백함수 -> 누적된값, 현재값 인자로 들어감\n//   // 첫 순회에서 맨 앞 두개 값 가져온다.\n//   // 현재 값은 그 다음에 더해줄 값\n//   // reduce는 누적값은 return문으로 출력\n//   //누적값 현재값 콘솔 찍어보기\n//   const handleReduce = function () {\n//     const reduced = array.reduce(function (acc, cur) {\n//       return `${acc} + ${cur}`;\n//     });\n//     setResult(reduced);\n//   };\n//   //  왜 array.push로 했을 때 변화가 없는지 설명하기!\n//   // 리액트가 변화를 감지하는 방법은 오직 set State를 통해서만 가능하다.\n//   const handlePush = function () {\n//     if (query.length <= 0) {\n//       alert(\"추가하시려는 값을 입력해주세요.\");\n//       return false;\n//     }\n//     const newArr = [...array, query];\n//     setArray(newArr);\n//     setResult(newArr.join(\", \"));\n//   };\n\n//   const handlePop = function () {\n//     // array.pop()으로는 백날 안됨..\n//     //1. 원본 배열을 통해 pop한 값을 저장함(임시변수에)\n//     const newArr = [...array];\n//     newArr.pop();\n\n//     //2. setArray\n//     setArray(newArr);\n//     //3. array를 기반으로 result생성(setResult)\n//     setResult(newArr.join(\", \"));\n//   };\n\n//   return (\n//     <div>\n//       <h1>Standard반 배열 API 테스트</h1>\n//       <input\n//         value={query}\n//         onChange={function (e) {\n//           setQuery(e.target.value);\n//         }}\n//       />\n//       <div>\n//         <button onClick={handleForEach}>forEach</button>\n//         <button onClick={handleFilter}>filter</button>\n//         <button onClick={handleMap}>map</button>\n//         <button onClick={handleReduce}>reduce</button>\n//         <button onClick={handlePush}>push</button>\n//         <button onClick={handlePop}>pop</button>\n//       </div>\n//       <div>\n//         <h3>원본배열</h3>\n//         <p>{array.join(\", \")}</p>\n//       </div>\n//       <div>\n//         <h3>결과물</h3>\n//         <p>{result}</p>\n//       </div>\n//     </div>\n//   );\n// }\n// export default App;","map":{"version":3,"names":[],"sources":["/Users/t2023-m0097/Desktop/PJ/react/my-app/src/App.jsx"],"sourcesContent":["// import { useState } from \"react\";\n// function App() {\n//   const initialState = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n//   const [array, setArray] = useState(initialState);\n//   const [result, setResult] = useState(\"\");\n//   const [query, setQuery] = useState(\"\");\n//   const a = [1, 2, 3, 4]\n//   delete a[1]\n//   console.log(a)\n\n//   const handleForEach = function () {\n//     let temp = \"\";\n//     array.forEach(function (item, index) {\n//       temp += `${index}: ${item}`;\n//     });\n//     setResult(temp);\n//   };\n\n//   const handleFilter = function () {\n//     const filtered = array.filter((item, index) => item.includes(query));\n//     setResult(filtered.join(\", \"));\n//   };\n\n//   const handleMap = function () {\n//     const mapped = array.map(function (item, index) {\n//       return item.toUpperCase();\n//     });\n//     setResult(mapped);\n//   };\n\n//   // reduce 배열 api 콜백함수 -> 누적된값, 현재값 인자로 들어감\n//   // 첫 순회에서 맨 앞 두개 값 가져온다.\n//   // 현재 값은 그 다음에 더해줄 값\n//   // reduce는 누적값은 return문으로 출력\n//   //누적값 현재값 콘솔 찍어보기\n//   const handleReduce = function () {\n//     const reduced = array.reduce(function (acc, cur) {\n//       return `${acc} + ${cur}`;\n//     });\n//     setResult(reduced);\n//   };\n//   //  왜 array.push로 했을 때 변화가 없는지 설명하기!\n//   // 리액트가 변화를 감지하는 방법은 오직 set State를 통해서만 가능하다.\n//   const handlePush = function () {\n//     if (query.length <= 0) {\n//       alert(\"추가하시려는 값을 입력해주세요.\");\n//       return false;\n//     }\n//     const newArr = [...array, query];\n//     setArray(newArr);\n//     setResult(newArr.join(\", \"));\n//   };\n\n//   const handlePop = function () {\n//     // array.pop()으로는 백날 안됨..\n//     //1. 원본 배열을 통해 pop한 값을 저장함(임시변수에)\n//     const newArr = [...array];\n//     newArr.pop();\n\n//     //2. setArray\n//     setArray(newArr);\n//     //3. array를 기반으로 result생성(setResult)\n//     setResult(newArr.join(\", \"));\n//   };\n\n//   return (\n//     <div>\n//       <h1>Standard반 배열 API 테스트</h1>\n//       <input\n//         value={query}\n//         onChange={function (e) {\n//           setQuery(e.target.value);\n//         }}\n//       />\n//       <div>\n//         <button onClick={handleForEach}>forEach</button>\n//         <button onClick={handleFilter}>filter</button>\n//         <button onClick={handleMap}>map</button>\n//         <button onClick={handleReduce}>reduce</button>\n//         <button onClick={handlePush}>push</button>\n//         <button onClick={handlePop}>pop</button>\n//       </div>\n//       <div>\n//         <h3>원본배열</h3>\n//         <p>{array.join(\", \")}</p>\n//       </div>\n//       <div>\n//         <h3>결과물</h3>\n//         <p>{result}</p>\n//       </div>\n//     </div>\n//   );\n// }\n// export default App;\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}